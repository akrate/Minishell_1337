#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <termios.h>
#include "libft/libft.h"
#include <readline/readline.h>
#include <readline/history.h>

typedef enum s_token_type
{
    T_IDENTIFIER,/*thsi is cmd or file name*/
    T_PIPE, /*this is pipe ->> '|'*/
    T_AND, /*this is and --> ' && '*/
    T_OR, /*this is or --> ' || '*/
    // T_O_PARENT, /*this is open Parenthesis --> ' ( ' */
    // T_C_PARENT, /*this is close Parenthesis --> ' ) '*/
    T_DGREAT, /*this is  double greater than --> ' >> '*/
    T_GREAT, /*this is greater than --> ' > '*/
    T_DLESS, /*this is double less than --> ' << ' */
    T_LESS, /*this is less than-->  ' < ' */
    
} t_token_type;

typedef struct s_qout
{
    int i;
    int in_quote;
    char quote_char;
    char *result;
    char *tmp;
} t_qout;

typedef struct s_cmd
{
    char *cmd;
    char *token;

} t_cmd;

typedef struct s_dolar
{
    int i;
    char *result;
    char *tmp;
    char *var_name;
    char *var_value;
    int in_single_quote;
    int in_double_quote;
    int start;
} t_dolar;

typedef struct s_list
{
    char *content;
    t_token_type type;
    struct s_list *next;
} t_list;

void paring_cmd(char *cmd);

int is_meta(char str);

int ft_lstadd_back(t_list **lst, t_list *new);

void ft_lstclear(t_list **lst);

int					ft_lstsize(t_list *lst);

char *checking_dolar(char *str);

char *ft_strjoin_free(char *s1, char *s2);

char *skip_qouts(char *str);

t_list *fill_node(char *content,t_token_type t_type);

int checking_close_qoutes(char *str);

int checking_cmd(t_list **list);


int main()
{
    char *cmd;
	// char *pwd = getcwd(NULL,0); ktjib path li kyn fiha;
    // paring_cmd("l shello \"jksgdfkjd\" ");
	// printf("%s\n",pwd);
    while (1)
    {
        cmd = readline("<minishell> ");
		if (!cmd)
        {
            printf("exit\n");
            break;
        }
        paring_cmd(cmd);
        // printf("%s\n",skip_qouts(cmd));
        if (*cmd)
            add_history(cmd);
    }

    return 0;
}
char *ft_strjoin_free(char *s1, char *s2)
{
    char *joined;
    
    joined = ft_strjoin(s1, s2);
    free(s1);
    free(s2);
    return joined;
}
static void init_solar(t_dolar *dolar)
{
    dolar->i = 0;
    dolar->start = 0;
    dolar->result = ft_strdup("");
    dolar->tmp = NULL;
    dolar->var_name = NULL;
    dolar->var_value = NULL;
    dolar->in_single_quote = 0;
    dolar->in_double_quote = 0;
}
char *checking_dolar(char *str)
{
    t_dolar dolar;

    init_solar(&dolar);
    while (str[dolar.i])
    {
        if (str[dolar.i] == '\'' && !dolar.in_double_quote)
        {
            dolar.in_single_quote = !dolar.in_single_quote;
            dolar.tmp = ft_substr(str, dolar.i, 1);
            dolar.result = ft_strjoin_free(dolar.result, dolar.tmp);
            dolar.i++;
        }
        else if (str[dolar.i] == '"' && !dolar.in_single_quote)
        {
            dolar.in_double_quote = !dolar.in_double_quote;
            dolar.tmp = ft_substr(str, dolar.i, 1);
            dolar.result = ft_strjoin_free(dolar.result, dolar.tmp);
            dolar.i++;
        }
        else if (str[dolar.i] == '$' && !dolar.in_single_quote)
        {
            dolar.start = ++dolar.i;
            if(!ft_isalnum(str[dolar.i]))
                return (str);
            while (str[dolar.i] && (ft_isalnum(str[dolar.i]) || str[dolar.i] == '_'))
                dolar.i++;
            dolar.var_name = ft_substr(str, dolar.start, dolar.i - dolar.start);
            dolar.var_value = getenv(dolar.var_name);
            free(dolar.var_name);
            if (dolar.var_value)
                dolar.result = ft_strjoin_free(dolar.result, ft_strdup(dolar.var_value));
        }
        else
        {
            dolar.tmp = ft_substr(str, dolar.i, 1);
            dolar.result = ft_strjoin_free(dolar.result, dolar.tmp);
            dolar.i++;
        }
    }
    return (dolar.result);
}

int is_meta(char str)
{
    if (str == '<' || str == '>' || str == '|')
        return (1);
    else 
        return (0);
}

int finde_meta(t_list *list)
{
    while (list)
    {
        if (list->type != T_IDENTIFIER)
            return (1);
        list = list->next;
    }
    return (0);
}
void get_pos(char *str,int *i)
{
    char c;
    if (str[*i] == '\'' || str[*i] == '"')
    {
        c = str[*i];
        (*i)++;
        while (str[*i] && str[*i] != c)
            (*i)++;
        if (str[*i] == c)
            (*i)++;
    }else{
        while (str[*i] && str[*i] != '\'' && str[*i] != '"' && str[*i] != ' ' && !is_meta(str[*i]))
            (*i)++;
    }
}
t_list *chr_meta(char *str,int *i)
{
    if (str[*i] == '<')
    {
        if (str[(*i) + 1] == '<')
        {
            if (is_meta(str[(*i) + 2]))
                return (write (1,"parse error\n",12),NULL);
            return ((*i) += 2,fill_node(ft_strdup("<<"),T_DLESS));
        }
        else
            return ((*i)++,fill_node(ft_strdup("<"),T_LESS));
    }else if (str[*i] == '>')
    {
        if (str[(*i) + 1] == '>')
        {
            if (is_meta(str[(*i) + 2]))
                return (write (1,"parse error\n",12),NULL);
            return ((*i) += 2,fill_node(ft_strdup(">>"),T_DGREAT));
        }
        else
            return ((*i)++,fill_node(ft_strdup(">"),T_GREAT));
    }else if (str[*i] == '|')
        return ((*i)++,fill_node(ft_strdup("|"),T_PIPE));
    return (NULL);
}
t_list *split_cmd(char *str)
{
    int i;
    int start;
    t_list *head = NULL;
    if (!str)
        return (NULL);
    i = 0;
    while (str[i] == ' ')
            i++;
    while (str[i])
    {
        while (str[i] == ' ')
            i++;
        start = i;
        while (str[i] && str[i] != ' ' && is_meta(str[i]) != 1)
            get_pos(str,&i);
        if (is_meta(str[i]))
        {
            if (ft_lstadd_back(&head,chr_meta(str,&i)) == 1)   
                 return (ft_lstclear(&head), NULL);
        }
        else
        {   
            if(ft_lstadd_back(&head,fill_znode(ft_substr(str,start,i - start),T_IDENTIFIER)) == 1)
             return (ft_lstclear(&head), NULL); 
        }
    }
    return (head);
}

void paring_cmd(char *cmd)
{
    t_list *args = split_cmd(cmd);
    
    t_list *tmp = args;
    if(!tmp)
    {
        write (1,"error\n",6);
        return ;
    }
    if (checking_cmd(&args) == 1)
        return ;
    while (tmp)
    {
        tmp->content = checking_dolar(tmp->content);
        tmp->content = skip_qouts(tmp->content);
        // printf("%s", (char *)tmp->content);
        tmp = tmp->next;
    }
    // if (finde_meta(args) == 1)
    //     hvhf
    // else
    
    printf ("\n");
}
const char *token_type_to_string(t_token_type type)
{
    if (type == T_IDENTIFIER)
        return "T_IDENTIFIER";
    if (type == T_PIPE)
        return "T_PIPE";
    if (type == T_AND)
        return "T_AND";
    if (type == T_OR)
        return "T_OR";
    if (type == T_DGREAT)
        return "T_DGREAT";
    if (type == T_GREAT)
        return "T_GREAT";
    if (type == T_DLESS)
        return "T_DLESS";
    if (type == T_LESS)
        return "T_LESS";
    return "UNKNOWN";
}
int	ft_lstadd_back(t_list **lst, t_list *new)
{
    t_list *tmp;
	if (!lst || !new)
		return (1);
	new->next = NULL;

	if (*lst == NULL)
	{
		*lst = new;
	}
	else
	{
		tmp = *lst;
		while (tmp->next != NULL)
			tmp = tmp->next;
		tmp->next = new;
	}
	return (0);
}
int	ft_lstsize(t_list *lst)
{
	int	i;

	i = 0;
	while (lst != NULL)
	{
		i++;
		lst = lst->next;
	}
	return (i);
}
void ft_lstclear(t_list **lst)
{
    t_list *current;
    t_list *next;

    if (!lst)
        return;
    current = *lst;

    while (current)
    {
        next = current->next;
        free(current->content);
        free(current);
        current = next;
    }

    *lst = NULL;
}

t_list *fill_node(char *content,t_token_type t_type)
{
    t_list	*node;

	node = (t_list *)malloc(sizeof(t_list));
	if (node == NULL)
		return (NULL);
	node->content = content;
    node->type = t_type;
	node->next = NULL;
	return (node);
}

int checking_close_qoutes(char *str)
{
    int i;
    char c;
    int d;

    d = 0;
    i = 0;
    while (str[i])
    {
        if(d == 0 && (str[i] == '\'' || str[i] == '"'))
        {   
            c = str[i++];
            d = 1;
        }
        while (str[i] && d != 0)
        {
            if (str[i] == c)
            {
                d = 0;
                break;
            }
            i++;
        }  
        i++;
    }
    return (d);
}
static void init_qouts(t_qout *strc)
{
    strc->i = 0;
    strc->in_quote = 0;
    strc->quote_char = 0;
    strc->result = ft_strdup("");
    strc->tmp = NULL;
}
char *skip_qouts(char *str)
{
    t_qout qout;

    init_qouts(&qout);
    while (str[qout.i])
    {
        if ((str[qout.i] == '\'' || str[qout.i] == '"') && qout.in_quote == 0)
        {
            qout.in_quote = 1;
            qout.quote_char = str[qout.i];
            qout.i++;
            continue;
        }
        if (str[qout.i] == qout.quote_char && qout.in_quote == 1)
        {
            qout.in_quote = 0;
            qout.quote_char = 0;
            qout.i++;
            continue;
        }
        qout.tmp = ft_substr(str, qout.i, 1);
        qout.result = ft_strjoin_free(qout.result, qout.tmp);
        qout.i++;
    }
    return qout.result;
}

int checking_cmd(t_list **list)
{
    t_list *lst;

    lst = *list;
    if (lst->type != T_IDENTIFIER)
    {
        write(2, "Error: command must end with identifier\n", 41);
        ft_lstclear(list);
        return (1);
    }
    while (lst)
    {
        if (checking_close_qoutes(lst->content) == 1)
        {
            write(2, "Error: unclosed quotes found\n", 29);
            ft_lstclear(list);
            return (1);
        }
        if (lst->next == NULL)
        {
            if (lst->type != T_IDENTIFIER)
            {
                write(2, "Error: command must end with identifier\n", 41);
                ft_lstclear(list);
                return (1);
            }
        }
        lst = lst->next;
    }
    return (0); 
}
